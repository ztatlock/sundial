<html>
<head>
  <title>Continuous Time</title>
  <script src='sprintf.js'></script>
  <script src='zip-longitude.js'></script>
  <link rel='stylesheet' type='text/css' href='z-style.css' />
</head>
<body>
  <h1>
    Continuous time at
    <input type='text' id='input'></input><span id='deg'>&deg;</span>
    is <span id='clock'></span>
  </h1>
  <br />
  <button type='button' class='control'
    onclick='switch_mode("LONG")'>Longitude</button>
  <button type='button' class='control'
    onclick='switch_mode("ZIP")'>ZIP</button>
  <button type='button' class='control'
    onclick='toggle_huh()'>Huh?</button>
  <div id='huh' style='visibility: hidden;'><p>

    Wall time already depends crudely on geographic location via timezone.
    However, unless you're right in the middle of your timezone, time isn't
    quite right for you, i.e. the sun isn't directly overhead at noon.

  </p><p>

    If we had 48 timezones instead of 24, the average error would be
    greatly reduced. 96 would be even better, and so on. If you continue
    down this path, you eventually just compute wall time as a function of
    UTC and longitude which is what this webpage does.

  </p></div>
  <script>
    'use strict';

    var MODE;
    var hour_ms = 1000 * 60 * 60; // millis in an hour
    var defaults = {
      ZIP: '92093',
      LONG: '-117'
    }

    function elem(id) {
      return document.getElementById(id);
    }

    function con_time(longitude) {
      var utc = new Date().getTime();
      var off = 12 * hour_ms * longitude / 180;
      var ctm = new Date(utc + off);
      return { hour: ctm.getUTCHours()
             , min:  ctm.getUTCMinutes()
             , sec:  ctm.getUTCSeconds()
             };
    }

    function setLong() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(useGeoLoc, useDefault);
      } else {
        useDefault();
      }

      function useGeoLoc(gl) {
        elem('input').value = gl.coords.longitude;
      }

      function useDefault(e) {
        elem('input').value = defaults.LONG;
      }
    }

    function show() {
      var l, z, t;

      // get longitude
      if(MODE === 'LONG') {
        l = elem('input').value;
      } else if(MODE === 'ZIP') {
        z = elem('input').value;
        l = zip_longitude[z];
      } else {
        error('BAD MODE');
      }

      // update display
      if(isNaN(l)) { // bogus longitude
        elem('clock').innerHTML = '??:??:??';
      } else {
        t = con_time(l);
        elem('clock').innerHTML =
          sprintf('%02d:%02d:%02d', t.hour, t.min, t.sec);
      }
    }

    function switch_mode(m) {
      MODE = m;
      if(m === 'LONG') {
        elem('deg').style.color = 'black';
        setLong();
      } else if(m === 'ZIP') {
        elem('deg').style.color = 'white';
        elem('input').value = defaults.ZIP;
      } else {
        error('BAD MODE');
      }
      show();
    }

    function toggle_huh() {
      var s = elem('huh').style;
      if(s.visibility === 'hidden') {
        s.visibility = 'visible';
      } else {
        s.visibility = 'hidden';
      }
    }

    function error(msg) {
      if(typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log(msg);
      } else {
        alert(msg);
      }
      location.reload();
    }

    switch_mode('LONG');
    setInterval(show, 1000); // update every second
  </script>
</body>
</html>
